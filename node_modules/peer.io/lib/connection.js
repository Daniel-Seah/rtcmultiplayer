function Connection(caller, callee, label) {
	/*
	 * Connection signaling state
	 * 
	 * Steps:
	 * Initial: Connection just started. Nothing expected
	 * 			from clients
	 * 
	 * Started: Offer triggered on caller. SDP expected from
	 * 			caller
	 * 
	 * Offered: Offer received from caller and sent to callee.
	 * 			SDP expected from callee. Candidates may be
	 * 			sent from caller
	 * 
	 * Answered: Answer received from callee and sent to caller.
	 * 			 Completion expected. Candidates may be sent from
	 * 			 callee
	 * 
	 * Completed: RTC connection is tested working. Nothing is
	 * 			  expected from clients
	 */
	var self = this;
	
	var state = 'initial';
	
	this.id = Connection.id;
	Connection.id++;
	
	caller.addConnection(this, callee);
	callee.addConnection(this, caller);
	
	var other = function(user) {
		if(user.socket === caller.socket) {
			return callee;
		} else if(user.socket === callee.socket) {
			return caller;
		}
		return null;
	};
	
	var isCaller = function(user) {
		if(caller.socket === user.socket) {
			return true;
		}
		return false;
	};
	
	var isCallee = function(user) {
		if(callee.socket === user.socket) {
			return true;
		}
		return false;
	};
	
	var connect = function() {
		// Initiate call from caller
		caller.socket.emit('offer', callee.id, label);
		state = 'started';
	};
	
	// Exchange SDP
	this.sdp = function(user, sdp) {
		var peer = other(user);
		var toAns = isCallee(peer);
		if(state === 'started' && isCaller(user) && toAns) {
			peer.socket.emit('remote sdp', user.id, sdp, toAns);
			state = 'offered';
		} else if(state === 'offered' && isCallee(user) && !toAns) {
			peer.socket.emit('remote sdp', user.id, sdp, toAns);
			state = 'answered';
		}
		
	};
	
	// Exchange ice candidate info
	this.candidate = function(user, candidate) {
		var peer = other(user);
		if(isCaller(user)) {
			if(state === 'offered' || state === 'answered'
			|| state === 'completed') {
				peer.socket.emit('remote candidate', user.id, candidate);
			}
		} else {
			if(state === 'answered' || state === 'completed') {
				peer.socket.emit('remote candidate', user.id, candidate);
			}
		}
	};
	
	this.finish = function() {
		caller.removeInterest(callee.id);
		caller.removeConnection(callee.id);
		caller = null;
		callee.removeInterest(caller.id)
		callee.removeConnection(caller.id);
		callee = null;
	};
	
	this.close = function(user) {
		if(user) {
			var peer = other(user);
			if(peer === null) {
				return;
			}
			peer.removeConnection(user.id);
			//peer.socket.emit('reset', user.id);
		} else {
			caller.removeConnection(callee.id);
			//caller.socket.emit('reset', callee.id);
			callee.removeConnection(caller.id);
			//callee.socket.emit('reset', caller.id);
		}		
	};
	
	connect();
}

Connection.id = 0;

module.exports = Connection;