/*
 * Negotiation objects facilitates a WebRTC peer to peer
 * connection by relaying session information between
 * peers until the connection is complete.
 * 
 * Whenever the user creates a new peer connection or adds
 * voice or data channels to an existing one, a new
 * negotiation object is created to exchange session
 * descriptors.
 * 
 * Connection signaling states:
 *   Initial: Connection just started. Nothing expected
 * 		from clients
 * 
 *   Started: Offer triggered on caller. SDP expected from
 * 		caller
 * 
 *   Offered: Offer received from caller and sent to callee.
 * 		SDP expected from callee. Candidates may be
 * 		sent from caller
 * 
 *   Answered: Answer received from callee and sent to caller.
 * 		Completion expected. Candidates may be sent from
 * 		callee
 * 
 *   Completed: RTC connection is tested working. Nothing is
 * 		expected from clients
 * 
 * Events:
 *   complete: Connection is tested working between peers and
 * 		negotiation is complete.
 * 
 *   close: One or more of the peers has disconnected from the
 * 		master server.
 * 
 * @author Daniel Seah
 */
var events = require('events');
var util = require('util');

function Negotiation(caller, callee, label) {
	var self = this;
	var state = 'initial';
	if(typeof label === 'undefined') {
		label = null;
	}
	
	var getUser = function(uid) {
		if(caller.id === uid) {
			return caller;
		} else if(callee.id === uid) {
			return callee;
		} else {
			return null;
		}
	};
	
	var other = function(user) {
		if(user.socket === caller.socket) {
			return callee;
		} else if(user.socket === callee.socket) {
			return caller;
		}
		return null;
	};
	
	var isCaller = function(user) {
		if(caller.socket === user.socket) {
			return true;
		}
		return false;
	};
	
	var isCallee = function(user) {
		if(callee.socket === user.socket) {
			return true;
		}
		return false;
	};
	
	var finishNegotiation1 = function(pid, lbl) {
		if(typeof pid !== 'string') {
			console.log('Finish peering: Invalid peer ID from ' + caller.id);
			return;
		}
		if(label !== lbl) {
			return;
		}
		
		finish(true);
	};
	
	var finishNegotiation2 = function(pid, lbl) {
		if(typeof pid !== 'string') {
			console.log('Finish peering: Invalid peer ID from ' + callee.id);
			return;
		}
		if(label !== lbl) {
			return;
		}
		
		finish(true);
	};
	
	var relaySDP1 = function(pid, sdp) {
		if(typeof pid !== 'string' || typeof sdp === 'undefined') {
			console.log('Description: Invalid descriptor from ' + caller.id);
			return;
		}
		var peer = other(caller);
		if(peer.id !== pid) {
			return;
		}
		sendSDP(caller, peer, sdp);
	};
	
	var relaySDP2 = function(pid, sdp) {
		if(typeof pid !== 'string' || typeof sdp === 'undefined') {
			console.log('Description: Invalid descriptor from ' + callee.id);
			return;
		}
		var peer = other(callee);
		if(peer.id !== pid) {
			return;
		}
		sendSDP(callee, peer, sdp);
	};
	
	var relayICE1 = function(pid, candidate) {
		if(typeof pid !== 'string' || typeof candidate === 'undefined') {
			console.log('Candidate: Invalid candidate from ' + caller.id);
			return;
		}
		var peer = other(caller);
		if(peer.id !== pid) {
			return;
		}
		sendCandidate(caller, peer, candidate);
	};
	
	var relayICE2 = function(pid, candidate) {
		if(typeof pid !== 'string' || typeof candidate === 'undefined') {
			console.log('Candidate: Invalid candidate from ' + callee.id);
			return;
		}
		var peer = other(callee);
		if(peer.id !== pid) {
			return;
		}
		sendCandidate(callee, peer, candidate);
	};
	
	this.connect = function() {
		// Add negotiation complete listeners
		caller.socket.on('connected', finishNegotiation1);
		callee.socket.on('connected', finishNegotiation2);
		
		// Listen for disconnects
		caller.socket.on('disconnect', close);
		callee.socket.on('disconnect', close);
		
		// Listen for SDP events
		caller.socket.on('sdp', relaySDP1);
		callee.socket.on('sdp', relaySDP2);
		
		// Listen for candidate events
		caller.socket.on('candidate', relayICE1);
		callee.socket.on('candidate', relayICE2);
		
		// Initiate call from caller
		caller.socket.emit('offer', callee.id, label);
		state = 'started';
	};
	
	// Exchange SDP
	var sendSDP = function(user, peer, sdp) {
		console.log('Debug: SDP info to ' + peer.id + ' - ' + sdp);
		var toAns = isCallee(peer);
		if(state === 'started' && isCaller(user)) {
			peer.socket.emit('remote sdp', user.id, sdp, toAns);
			state = 'offered';
		} else if(state === 'offered' && isCallee(user)) {
			peer.socket.emit('remote sdp', user.id, sdp, toAns);
			state = 'answered';
			// Finish connection for stream negotiation
			if(label === null) {
				finish();
			}
		}
	};
	
	// Exchange ice candidate info
	var sendCandidate = function(user, peer, candidate) {
		console.log('Debug: Candidate info to ' + peer.id + ' - ' + candidate);
		if(isCaller(user)) {
			if(state === 'offered' || state === 'answered'
			|| state === 'completed') {
				peer.socket.emit('remote candidate', user.id, candidate);
			}
		} else {
			if(state === 'answered' || state === 'completed') {
				peer.socket.emit('remote candidate', user.id, candidate);
			}
		}
	};
	
	var finish = function() {
		console.log('Debug: ' + caller.id + ' and ' + callee.id + ' labelled "' + label + '" completed negotiation');
		
		caller.socket.removeListener('candidate', relayICE1);
		callee.socket.removeListener('candidate', relayICE2);
		caller.socket.removeListener('sdp', relaySDP1);
		callee.socket.removeListener('sdp', relaySDP2);
		caller.socket.removeListener('disconnect', close);
		callee.socket.removeListener('disconnect', close);
		caller.socket.removeListener('connected', finishNegotiation1);
		callee.socket.removeListener('connected', finishNegotiation2);
		
		caller.removeInterest(callee.id, label);
		callee.removeInterest(caller.id, label);
		caller = null;
		callee = null;
		self.emit('complete');
	};
	
	var close = function() {
		self.emit('close');
	};
}

util.inherits(Negotiation, events.EventEmitter);

module.exports = Negotiation;