/*
 * Master server for game rooms
 * 
 * Users are organised into smaller groups(rooms). Users
 * in the same room communicate within themselves and run
 * their own game server.
 * 
 * Game communications do not go through this master
 * server. RoomServer only hosts rooms by organising
 * users.
 * 
 * Users can only join rooms when they have a mutual
 * friend participating. 
 * 
 * @author Daniel Seah
 */
var http = require('http');
var Room = require('./room');
var util = require('util');
var events = require('events');
var games = require('../../../games');

// TODO add server migration
function RoomServer(io) {
	var sio = io;
	if(typeof sio === 'undefined') {
		var app = http.createServer( function(req, res) {} );
		sio = require('socket.io').listen(app);
		app.listen(80);
	}
	
	var self = this;
	
	var rs = sio.of('/room');
	var users = {};
	var nRooms = 0;
	var rooms = {};
	
	// TODO implement support for passwords
	var createRoom = function(gameID, password) {
		var room = new Room('' + nRooms, gameID);
		nRooms++;
		rooms[room.id] = room;
		room.maxUsers = games.describe[gameID].size;
		room.password = password || '';
		return room;
	};
	
	rs.on('connection', function(socket) {
		users[socket.handshake.fbid] = socket;
		
		var addUser = function(roomID, userID) {
			if(arguments.length < 2) {
				userID = socket.handshake.fbid;
			}
			var room = rooms[roomID];
			var userSock = users[userID];
			
			room.addUser(userID);
			
			// Socket rooms
			self.emit('user joins', userID, roomID);
			userSock.join(roomID);
			userSock.join('observe/' + roomID);
			userSock.broadcast.to(roomID).emit('user enter', roomID, userID);
			userSock.broadcast.to('observe/' + room.id).emit('user enter', roomID, userID);
		};
		
		var removeUser = function(roomID, userID) {
			if(arguments.length < 2) {
				userID = socket.handshake.fbid;
			}
			var room = rooms[roomID];
			if(typeof room === 'undefined') {
				return;
			}
			var userSock = users[userID];
			if(typeof userSock === 'undefined') {
				return;
			}
			if(!room.contains(userID)) {
				return;
			}
			
			// Socket room
			socket.broadcast.to(roomID).emit('user exit', roomID, userID);
			socket.broadcast.to('observe/' + roomID).emit('user exit', roomID, userID);
			userSock.leave(roomID);
			
			room.removeUser(userID);
			self.emit('user leaves', userID, roomID);
			
			// Remove room if empty
			if(room.users.length <= 0) {
				delete rooms[room.id];
			}
		};
	
		socket.on('create', function(gameID, password, reply) {
			var room = createRoom(gameID, password);
			addUser(room.id);
			room.host = socket.handshake.fbid;
			
			// Send room information
			reply(room.id, gameID, room.maxUsers, room.users, null);
			
			// Start server
			socket.emit('host', room.id, null);
			
			// Start client
			socket.emit('run client', room.id, room.host);
		});
		
		socket.on('join', function(id, referrer, password, reply) {
			var room = rooms[id];
			if(typeof room === 'undefined') {
				reply(null, null, null, null, 'no room');
				return;
			}
			// TODO check that referrer is a friend
			if(!room.contains(referrer)) {
				reply(null, null, null, null, 'referrer error');
				return;
			}
			if(room.password !== password) {
				reply(null, null, null, null, 'password');
				return;
			}
			if(!room.isOpen) {
				reply(null, null, null, null, 'closed');
				return;
			}
			if(room.users.length >= room.maxUsers) {
				reply(null, null, null, null, 'full');
				return;
			}
			if(room.contains(socket.handshake.fbid)) {
				reply(null, null, null, null, 'already joined');
				return;
			}
			
			// Add user to room
			addUser(room.id)
			reply(room.id, room.game, room.maxUsers, room.users, null);
			
			// Start client
			socket.emit('run client', room.id, room.host);
		});
		
		socket.on('subscribe', function(id, reply) {
			var room = rooms[id];
			if(typeof room === 'undefined') {
				reply(null, null, 'no room');
				return;
			}
			reply(room.id, room.game, room.maxUsers, room.users, null);
			socket.join('observe/' + id);
		});
		
		/*
		 * Removes user from the room.
		 * Called by the server when connection is lost to client. Can
		 * only be called by the server.
		 */
		socket.on('remove user', function(roomID, userID) {
			if(socket.handshake.fbid !== rooms[roomID].host) {
				return;
			}
			
			removeUser(roomID, userID)
		});
		
		socket.on('leave', function(id) {
			removeUser(id);
		});
		
		// TODO do we disconnect user from game session if connection to master server is lost?
		socket.on('disconnect', function() {
			var joined = socket.manager.roomClients[socket.id];
			for(var i = 0; i < joined.length; i++) {
				var name = joined[i].slice(1);
				if(name === '') {
					continue;
				}
				removeUser(id);
			}
			delete users[socket.handshake.fbid];
		});
	});
}

util.inherits(RoomServer, events.EventEmitter);
module.exports = RoomServer;